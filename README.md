# cg-lab-open-ended-experiment
This repo contains the source code for "A custom rendering engine, from scratch", written in C++. This work has been completed as per requirements of 16CS73 (Computer Graphics) Lab. 

[Click here for project slides]()
[Click here for project report]()

# Abstract 
*Computer graphics has revolutionized the way the computing world thinks and solves complex and challenging problems of the rapidly changing world. Applications spanning a variety of domains have computer graphics as an essential component all through its development, deployment, utility and maintenance. Therefore, it becomes imperative for developers of all kinds to acquire knowledge of appropriate graphics libraries while designing any user-facing application intended for desktop/mobile/ web. We believe that in order to write efficient applications using 3D graphics libraries, it is crucial to understand how they work and not merely what utility they provide. This is not a very intuitive approach as the very existence of these libraries is to alienate the developer from the nitty-gritties of the graphics world. Nonetheless, taking a bottom-up approach to learning development of graphics-rich application development, by attempting to look under-the-hood and decode the black box of graphics libraries, is likely to pay off in the long run. In an attempt to illustrate this school of thought, this project shall focus on “building a custom rendering engine in C++, to construct a 2D scene from 3D object models, by implementing various stages of 3D graphics pipeline, from scratch, without using external graphics libraries”.  This would NOT be an application designed to leverage OpenGL. Rather, it would be an attempt to de-abstract the rendering task, split this task into various sub-tasks, implement such sub-tasks and observe intermittent results to identify key technical challenges and their workarounds. This requires that we deliberately push to eliminate support of third-party libraries (especially the graphics ones). To summarize, we would like to simulate the 3D graphics pipeline and explore the innate complexities in rendering 2D scenes using 3D models. This problem could also be modelled as an attempt to write a “clone” (albeit, a much simplified one) of 3D graphics libraries such as OpenGL/ DirectX.*
 
# Notes regarding source code 
The source code for this work includes several projects implementing the various subtasks that we broke the original task into. This can be thought of to be equivalent to versioning. In an ideal development scenario, the software would be developed through its various stages while maintaining versioning through tools like git. However, in this work, in order to better illustrate the breakdown of tasks and generate renders at all intermittent stages, we have retained the implementations of individual stages as separate projects, enforcing more clarity at the expense of some unnecessary redundancy. 

### List of projects:
•	1_WIREFRAME_RENDERING – Building the wireframe mesh by drawing lines  
•	2_RASTERIZING_TRIANGLES_AND_BACK_FACE_CULLING – Filling the triangles and back face culling  
•	3_HIDDEN_SURFACE_REMOVAL – Adding the Z-buffer to perform hidden surface removal  
•	4_PERSPECTIVE_PROJECTION – Adding perspective to the render  
•	5_MOVING_THE_CAMERA_+_GOURAUD_SHADING – Adding ability to move the camera and implementing Gouraud shading  
•	6A_SHADERS_PHONG_+_SPECULAR_MAPPING – Adding Phong shading and specular mapping  
•	6B_TANGENT_SPACE_NORMAL_MAPPING – Adding tangent space normal mapping  
•	7_SHADOW_MAPPING – Adding ability to add shadow effects  
•	8_AMBIENT_OCCLUSION – Adding option to include ambient occlusion  
•	9_PERSPECTIVE_AWARE_INTERPOLATION – Solving the technical difficulty (see appendix C) of using homogeneous coordinates  
•	FINAL_CUSTOM_RENDERER_FROM_SCRATCH – The final version (as of this instance) containing the features depicted in previous projects   
•	POC_RENDERING_USING_OPENGL – Comparing our work with using OpenGL for a POC rendering task  

# Notes regarding setting up the dev environment 
The work was completely done within the framework of Visual Studio 2019. We have created a visual studio solution contains 11 projects, each illustrating the progression through the stages of development. The headache of linking libraries and their dependencies is avoided by the very nature of the project. A C++ compiler is all that is required to compile and run the projects. Using Visual Studio 2019 is recommended for the same, albeit using any other editor or even the command line should work. The source code should compile and run on any platform. However, since we used Visual Studio 2019 on Windows 10 to create the projects, there might be some issues while attempting to run the projects on Linux and MacOS. As of this moment, we have not tested the code on other platforms. It is important to note that the obj folder that contains the obj files for the models and the texture images (in TGA format) must reside in the same directory as that of the exe. The first few projects (stages of development) have the African male model as the default input (hardcoded into the source code). The final complete  project allows the object files to be passed as arguments. Within the framework of Visual Studio 2019, this can be done by going to project settings  debugging and tweaking the command line arguments to be passed to main() on clicking run. One might experience difficulty in opening TGA files and may require installing TGA viewer or other such software to open the same as native support might not exist for the TGA format. If one is looking forward to just execute the programs, they could do so by just running the .exe found in the debug directory of each project. But in case they wish to tweak the command line arguments (the option available for final few stages as explained above), they might have to use command prompt to run the exe or run the projects from Visual Studio 2019 after altering project debugging settings as mentioned before. 
